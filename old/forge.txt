package controller

import (
	"fmt"

	networkingv1beta1 "github.com/liqotech/liqo/apis/networking/v1beta1"
	networkingv1beta1firewall "github.com/liqotech/liqo/apis/networking/v1beta1/firewall"
	tenantnamespace "github.com/liqotech/liqo/pkg/tenantNamespace"
	"k8s.io/utils/ptr"

	securityv1 "github.com/riccardotornesello/liqo-security-manager/api/v1"
)

// Remove the tenantnamespace.NamePrefix + "-" from the namespace to get the cluster ID
func extractClusterID(namespace string) (string, error) {
	const prefix = tenantnamespace.NamePrefix + "-"

	if len(namespace) <= len(prefix) || namespace[:len(prefix)] != prefix {
		return "", fmt.Errorf("namespace %q does not have the expected prefix %q", namespace, prefix)
	}
	return namespace[len(prefix):], nil
}

// func generateVcRemotePodsSetElements(ctx context.Context, cl client.Client, remoteClusterID string) ([]string, error) {
// 	// TODO: optimize and execute only for provider

// 	// Get the pods coming from the remote cluster.
// 	podList := &corev1.PodList{}
// 	if err := cl.List(ctx, podList, client.MatchingLabels{
// 		forge.LiqoOriginClusterIDKey: remoteClusterID,
// 	}); err != nil {
// 		return nil, err
// 	}

// 	destinationPodIps := make([]string, 0, len(podList.Items))
// 	for _, pod := range podList.Items {
// 		if pod.Status.PodIP != "" {
// 			destinationPodIps = append(destinationPodIps, pod.Status.PodIP)
// 		}
// 	}

// 	return destinationPodIps, nil
// }

func forgeGatewaySpec(cfg *securityv1.PeeringSecurity) (*networkingv1beta1.FirewallConfigurationSpec, error) {
	// // Parse the default isolation policy

	// switch cfg.Spec.IsolationPolicy {
	// case securityv1.IsolationPolicyAllow:
	// 	policy = networkingv1beta1firewall.ChainPolicyAccept

	// case securityv1.IsolationPolicyBlockTunnel:
	// 	policy = networkingv1beta1firewall.ChainPolicyDrop

	// case securityv1.IsolationPolicyBlockBorder:
	// 	policy = networkingv1beta1firewall.ChainPolicyDrop
	// 	isolationFilterRules = []networkingv1beta1firewall.FilterRule{
	// 		{
	// 			Name:   ptr.To("isolation-allow-vc-local-to-vc-remote"),
	// 			Action: networkingv1beta1firewall.ActionAccept,
	// 			Match: []networkingv1beta1firewall.Match{{
	// 				Op: networkingv1beta1firewall.MatchOperationEq,
	// 				IP: &networkingv1beta1firewall.MatchIP{
	// 					Position: networkingv1beta1firewall.MatchPositionDst,
	// 					Value:    fmt.Sprintf("@%s", gatewayVcRemotePodsSetName),
	// 				},
	// 			}},
	// 		},
	// 	}
	// 	requiredSets = map[string]struct{}{
	// 		gatewayVcRemotePodsSetName: {},
	// 	}

	// default:
	// 	return nil, fmt.Errorf("unknown isolation policy %q", cfg.Spec.IsolationPolicy)
	// }

	// // Ensure required sets are present
	// // TODO
	// fmt.Println("Required sets:", requiredSets)

	var policy networkingv1beta1firewall.ChainPolicy
	filterRules := []networkingv1beta1firewall.FilterRule{
		{
			Name:   ptr.To("allow-established-related"),
			Action: networkingv1beta1firewall.ActionAccept,
			Match: []networkingv1beta1firewall.Match{{
				CtState: &networkingv1beta1firewall.MatchCtState{
					Value: []networkingv1beta1firewall.CtStateValue{
						networkingv1beta1firewall.CtStateEstablished,
						networkingv1beta1firewall.CtStateRelated,
					},
				},
				Op: networkingv1beta1firewall.MatchOperationEq,
			}},
		},
		{
			Name:   ptr.To("only-from-tunnel"),
			Action: networkingv1beta1firewall.ActionAccept,
			Match: []networkingv1beta1firewall.Match{{
				Dev: &networkingv1beta1firewall.MatchDev{
					Position: networkingv1beta1firewall.MatchDevPositionIn,
					Value:    "liqo-tunnel",
				},
				Op: networkingv1beta1firewall.MatchOperationNeq,
			}},
		},
		{
			Name:   ptr.To("allow-eth"),
			Action: networkingv1beta1firewall.ActionAccept,
			Match: []networkingv1beta1firewall.Match{{
				Dev: &networkingv1beta1firewall.MatchDev{
					Position: networkingv1beta1firewall.MatchDevPositionOut,
					Value:    "eth0",
				},
				Op: networkingv1beta1firewall.MatchOperationEq,
			}},
		},
	}

	if cfg.Spec.BlockTunnelTraffic {
		policy = networkingv1beta1firewall.ChainPolicyDrop
	} else {
		policy = networkingv1beta1firewall.ChainPolicyAccept
	}

	return &networkingv1beta1.FirewallConfigurationSpec{
		Table: networkingv1beta1firewall.Table{
			Name:   ptr.To(gatewayTableName),
			Family: ptr.To(networkingv1beta1firewall.TableFamilyIPv4),
			Chains: []networkingv1beta1firewall.Chain{{
				Name:     ptr.To(gatewayChainName),
				Hook:     ptr.To(networkingv1beta1firewall.ChainHookPostrouting),
				Policy:   ptr.To(policy),
				Priority: ptr.To[networkingv1beta1firewall.ChainPriority](gatewayChainPriority),
				Type:     ptr.To(networkingv1beta1firewall.ChainTypeFilter),
				Rules: networkingv1beta1firewall.RulesSet{
					FilterRules: filterRules,
				},
			}},
		},
	}, nil
}
